redis服务器一般会分配服务器60%-70%的内存用于内存存储数据，可以设置maxmemory最大可用内存

1.redis特性
(1)速度快(c语言，内存缓存读取,非堵塞IO,每秒可执行10万条命令)
(2)持久化(异步将数据保存在磁盘中)
(3)多种数据结构(key-value, hash-tables, linked lists, sets, sorted sets)，一个key或value值最大可存512M
(4)主从复制
(5)高可用，分布式
(6)简单(单线程，一次只运行一条命令，最好不要在生产环境执行命令，因为是单线程)

2.redis应用场景
缓存系统(减少访问实体数据库的请求)
计数器
消息队列系统
排行榜
实时系统

3.redis通常使用架构
client客户端访问--->Server服务器--->redis获取缓存--->
如果redis存在缓存，则直接在redis获取。
如果redis为null，则穿透到数据库中获取，再将值更新回redis中，以供下次redis使用。

注意：client客户端跟redis服务器是开启TCP连接通信，其中 RESP 是redis客户端和服务端之前使用的一种通讯协议。

4.redis持久化策略
(1)生成RDB文件(二进制数据文件，内存数据的文件，快照)
save：
客户端发送请求到redis服务器后，由于save命令会堵塞redis中的线程任务，所以其他请求会阻塞
等待save命令在RDB文件中保存完毕后，redis才能处理其他请求。
缺点是:影响效率。

bgsave：
由于bgsave命令是异步持久化内存数据，redis服务器会开多一个子线程(fork()操作)，用于保存数据在RDB
文件中，同时redis服务器可以处理其他客户端请求。
缺点是:消耗内存。

(2)AOF(保存redis执行命令的文件，保存每一条redis执行的命令，恢复时只要执行命令即可)
always：
系统会将redis执行命令先写在磁盘的缓冲区中，然后每条命令fsnyc到硬盘的AOF文件中。

everysec：
everysec与always区别就是每秒钟保存数据一次，但是可能保存时会丢失一秒的数据，因为新操作要等当前线程执行完才能生成，有线程堵塞。

bgrewriteaof(AOF重写)：
例如：对一个key相同操作(假如set)的命令只获取最后有用命令,并写入AOF文件的操作。
使用bgrewriteaof会使用fork命令异步生成一个子线程，实现AOF重写。
优点：减少磁盘占用量，加快恢复速度

redis服务器持久化建议：
1.关闭RDB，因为实现持久化，只需要在主redis服务器中，执行一句save就可以生成RDB文件,并且恢复时消耗内存，一般用于服务器所有内存丢失等情况。
2.默认开启AOF，使用everysec实现AOF，消耗小，轻量级，执行命令相对于从RDB文件读取数据并且恢复要快。


5.redis主从复制(高可用,一主多从)
(1)从服务器通过从主服务器中复制内存数据到自己服务器中，可以实现数据同步(一个从机只能有一个主机，并且数据是单向的，只能主到从);
(2)请求分流，类似于负载均衡，可以进行请求分流处理。
(3)实现读写分离，主机负责写入数据，从机获取主机数据并负责提供只读数据。

如何实现主从复制：
(1)命令实现
准备好从机，并且安装好redis服务，确认主机的redis的url地址，端口，
在从机上面执行命令(异步)：slaveof 127.0.0.1:6379
清除所复制的主机内存数据：slaveof no one

(2)配置实现
在redis.conf文件中添加命令 slaveof 127.0.0.1:6379，并且重启从机即可。

心跳检测(从机发送信息)
心跳检测发生在命令传播阶段，从节点默认每秒发送一次心跳检测命令 REPLCONF ACK <偏移量> 获取主节点心跳。
发送该命令主要为了：检测主从服务器的网络连接状态、辅助实现min-slave选项、检测命令是否丢失。

主从全量复制实现原理(可参考图片,即是根据主机的RDB文件重新读取数据到内存中): 需要配置好slaveof命令并且重启从机，新配置从机时候应用
1.从机向主机发送psync同步数据请求。
2.主机发送redis程序运行runid以及数据偏移量offset。
3.从机保存主机的信息。
4.主机执行bgsave命令，异步生成RDB数据文件。
5.向从机发送RDB数据文件。
6.从机清除老数据。
7.从机加载RDB文件数据到内存中。

主从部分复制(实时):(简单来说就是在runid一致前提,通过两边offset进行比较，对偏差数据进行数据同步)
从机连接主机后，会主动发起 PSYNC 命令，从机会提供 master 的 runid(机器标识，随机生成的一个串) 和 offset（数据偏移量，如果offset主从不一致则说明数据不同步），
主机验证 runid 和 offset 是否有效，runid 相当于主机身份验证码，用来验证从机上一次连接的主机，
如果 runid 验证未通过则，则进行全同步，如果验证通过则说明曾经同步过，根据 offset 同步部分数据。


故障处理：
1.如果主机宕机了，从机会断开与主机的连接，并且无法执行数据同步
方案：修改配置，将其中一台从机使用slave no one取消与之前主机的联系，
变为新主机，其他从机使用slaveof新主机地址，将他视为新主机即可。最好先准备一份配置文件，出问题直接替换重启即可。

6.Redis哨兵（Sentinel）模式:
哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。
其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。
Sentinel 可以通过 API 向管理员或者其他应用程序发送通知(应该是自己在代码中写入)。

哨兵模式工作任务:
a、监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常(每秒钟都发送ping)。
b、提醒(Notification):当被监控的某个 Redis出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。
c、自动故障迁移(Automatic failover):当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master; 当客户端试图连接失效的Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。

7.Redis Cluster(高可用，高扩展，高性能)
Redis Cluster是一个去中心化的分布式实现方案，客户端和集群中任一节点连接，然后通过后面的交互流程，逐渐的得到全局的数据分片映射关系。
Redis Cluster Bus通过单独的端口进行连接，由于Bus是节点间的内部通信机制，交互的是字节序列化信息。相对Client的字符序列化来说，效率较高。
Redis Cluster其实是一个大型的redis集群，他可以将所有缓存数据存储到对应所有节点上。

拓扑结构(可参考图，Redis Cluster结构)：
一个Redis Cluster由多个Redis节点组成。不同的节点组服务的数据无交集(一共16384个节点)，每个节点对应数据sharding的一个分片。
节点组内部分为主备2类，对应前面叙述的master和slave。两者数据准实时一致，通过异步化的主备复制机制保证。
一个节点组有且仅有一个master，同时有0到多个slave。只有master对外提供写服务，读服务可由master/slave提供。

个人Redis Cluster的大概理解： https://www.jianshu.com/p/84dbb25cc8dc
数据分库分表规则：由于集群分为16384个slots（即hash槽，和集群节点，每个集群master都会持有部分slots），slot是数据映射的基本单位，
通过hash（key）% N(节点数)，计算出数据映射到哪一个节点上，通过不同master对接不同slots，实现数据分库分表规则。
缺点：如果是添加(扩容)或减少节点，会导致数据重新迁移分配。

高可用：就是把一个主从结构redis服务集群放在一个节点里面，每个节点之间都可以相互通信，所以一个节点中
有主机出现问题后，当前结点就会使用投票机制选出下一个从机作为主机，继续运行。
可高扩展：每个节点相当于一个容器，可以随时添加集群，或者随时扩容。


9.redis分布式锁
出现场景：一个支付订单下单后，可能同时触发2个redis操作，1.消费扣款，2.扣库存。如果没有分布式锁，可能会出现如下情况
扣款失败了，但是库存扣成功了。因为2个操作没有事务的原子性，因此，redis分布式服务器情况下，有必要添加锁。

redis提供的锁命令
setnx key value：同步锁，存在该key，才能修改key
getset key value：解决死锁，用新锁代替旧锁

10.redis异步队列
(1)使用list实现：repush命令生产消息，lpop消费消息，缺点是如果内存丢失，队列也会丢失
(2)使用主题订阅者模式(pub发送者/sub订阅者)，实现命令：
1.subscribe myTopic，消费者需要订阅的频道。
2.publish myTopic "Hello",生产者发送Hello信息。
3.监听myTopic消费者都会受到信息。
缺点是无法确保消息发送是否成功，发送消息情况不可控。