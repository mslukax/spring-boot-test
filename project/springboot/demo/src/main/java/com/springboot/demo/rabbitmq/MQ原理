1.使用场景
在我们秒杀抢购商品的时候，系统会提醒我们稍等排队中，而不是像几年前一样页面卡死或报错给用户。
像这种排队结算就用到了消息队列机制，放入通道里面一个一个结算处理，而不是某个时间断突然涌入大批量的查询新增把数据库给搞宕机，
所以RabbitMQ本质上起到的作用就是削峰填谷，为业务保驾护航。

2.优点
1.除了Qpid，RabbitMQ是唯一一个实现了AMQP标准的消息服务器；
2.可靠性，RabbitMQ的持久化支持，保证了消息的稳定性；
3.高并发，RabbitMQ使用了Erlang开发语言，Erlang是为电话交换机开发的语言，天生自带高并发光环，和高可用特性；
4.集群部署简单，正是应为Erlang使得RabbitMQ集群部署变的超级简单；
5.社区活跃度高，根据网上资料来看，RabbitMQ也是首选；

3.工作机制
(1)生产者、消费者和代理
生产者：消息的创建者，负责创建和推送数据到消息服务器；
消费者：消息的接收方，用于处理数据和确认消息；
代理：就是RabbitMQ本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。

(2)消息发送原理
你的应用程序和Rabbit Server之间会创建一个TCP连接，一旦TCP打开，并通过了认证，认证就是你试图连接Rabbit之前发送的Rabbit服务器连接信息和用户名和密码，
有点像程序连接数据库，一旦认证通过你的应用程序和Rabbit就创建了一条AMQP信道（Channel）。
信道是创建在“真实”TCP上的虚拟连接，AMQP命令都是通过信道发送出去的，每个信道都会有一个唯一的ID，不论是发布消息，订阅队列或者介绍消息都是通过信道完成的。

注意:由于TCP会话开销比较大，所以每个请求(一个外部服务器)跟MQ服务器的交互都是通个一个TCP链接进行。


4.RabbitMQ基本概念
ConnectionFactory(连接工厂)：生产Connection的的工厂；
Connection(连接)：RabbitMQ的socket的长链接，它封装了socket协议相关部分逻辑；
Channel(频道|信道)：建立在Connection连接之上的一种轻量级的连接，我们大部分的业务操作是在Channel这个接口中完成的；
包括定义队列的声明queueDeclare、交换机的声明exchangeDeclare、队列的绑定queueBind、发布消息basicPublish、消费消息basicConsume等。
如果把Connection比作一条光纤电缆的话，那么Channel信道就比作成光纤电缆中的其中一束光纤。一个Connection上可以创建任意数量的Channel；

Producer(生产者)：生产者用于发布消息；
Exchange(交换机)：生产者会将消息发送到交换机，然后交换机通过路由策略(规则)将消息路由到匹配的队列中去；
Routing Key(路由键)：一个String值，用于定义路由规则，在队列绑定的时候需要指定路由键，在生产者发布消息的时候需要指定路由键，当消息的路由键和队列绑定的路由键匹配时，消息就会发送到该队列。
Queue(队列)：用于存储消息的容器，可以看成一个有序的数组，生产者生产的消息会发送到交换机中，最终交换机将消息存储到某个或某些队列中，队列可被消费者订阅，消费者从订阅的队列中获取消息。
Binding(绑定)：Binding并不是一个概念，而是一种操作，RabbitMQ中通过绑定，以路由键作为桥梁将Exchange与Queue关联起来(Exchange—>Routing Key—>Queue)，这样RabbitMQ就知道如何正确地将消息路由到指定的队列了，通过queueBind方法将Exchange、Routing Key、Queue绑定起来.

Consumer(消费者)：用于从队列中获取消息，消费者只需关注队列即可，不需要关注交换机和路由键，消费者可以通过basicConsume(订阅模式可以从队列中一直持续的自动的接收消息)或者basicGet(先订阅消息，然后获取单条消息，再然后取消订阅，也就是说basicGet一次只能获取一条消息，如果还想再获取下一条还要再次调用basicGet)来从队列中获取消息
vhost(虚拟主机):每一个RabbitMQ服务器都能创建虚拟消息服务器，我们称之为虚拟主机。每一个vhost本质上是一个mini版的RabbitMQ服务器，拥有自己的交换机、队列、绑定等，拥有自己的权限机制。vhost之于Rabbit就像虚拟机之于物理机一样。他们通过在各个实例间提供逻辑上分离，允许为不同的应用程序安全保密的运行数据，
这很有，它既能将同一个Rabbit的众多客户区分开来，又可以避免队列和交换器的命名冲突。RabbitMQ提供了开箱即用的默认的虚拟主机“/”，如果不需要多个vhost可以直接使用这个默认的vhost，通过使用缺省的guest用户名和guest密码来访问默认的vhost.
vhost之间是相互独立的，这避免了各种命名的冲突，就像App中的沙盒的概念一样，每个沙盒是相互独立的，且只能访问自己的沙盒，以保证非法访问别的沙盒带来的安全隐患。

其他：
Channel两种模式：
1.信道可以添加事务，可以实现生产者消息回滚，和消息可靠性，但是效率慢；
2.信道可以添加confirm模式确认消息接受，confirm包含异步处理，速度比事务快，可以同个消息唯一ID确认消息是否已发送或者消费
生产者发送方确认模式：ack(确认),nack(未确认)
消费者消费确认模式：ack(确认)，默认断开重发

Exchange三种模式模式： (性能排序：fanout > direct > topic)
1.fanout模式：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。
很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。(重复消费问题)
2.direct模式：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。即是根据Routing key绑定队列名。
3.topic模式：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.*” 只会匹配到“audit.irs”
任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上。(很好地根据规则区分队列)


架构工作流程:
生产者发送消息--->ConnectionFactory（连接管理器）--->MQ Server--->vhost(虚拟主机)--->Exchange（交换器）--->Binding操作(根据RoutingKey（路由键）)--->
Queue（队列）--->消费者监听信息并且消费


5.消息持久化
Rabbit队列和交换器默认情况下重启服务器会导致消息丢失，那么怎么保证Rabbit在重启的时候不丢失呢？答案就是消息持久化。
Rabbit会将你的持久化消息(队列参数等)写入磁盘上的持久化日志文件，等消息被消费之后，Rabbit会把这条消息标识为等待垃圾回收。

注意:消耗内存，降低了服务器的吞吐量。


6.生产者消费者全部职责
生产者:
(1)生产者连接到RabbitMQ Broker，建立一个连接( Connection)开启一个信道(Channel)
(2)生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等
(3)生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等
(4)生产者通过路由键将交换器和队列绑定起来
(5)生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。
(6)相应的交换器根据接收到的路由键查找相匹配的队列。
(7)如果找到，则将从生产者发送过来的消息存入相应的队列中。
(8)如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者
(9)关闭信道。
(10)关闭连接。

消费者:
(1)消费者连接到RabbitMQ Broker ，建立一个连接(Connection)，开启一个信道(Channel) 。
(2)消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，
(3)等待RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。
(4)消费者确认(ack) 接收到的消息。
(5)RabbitMQ 从队列中删除相应己经被确认的消息。
(6)关闭信道。
(7)关闭连接。
