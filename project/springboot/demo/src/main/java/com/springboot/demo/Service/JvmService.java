package com.springboot.demo.Service;

public class JvmService {

    //jvm类加载
    public void JvmGainian(){
        //1.java平台无关性,详细浏览 pricture jvm。
        //java代码将会被编译(javac)成字节码，存储在.class中，再由不同平台版本的jvm虚拟机(ios/window)去解析，转换成各种平台上的机器指令


        //2.jvm加载类文件
        //加载过程：java源码--->编译生成class文件--->ClassLoader加载(主要)--->Runtime Data Area(jvm内存结构模型)

        //ClassLoader类加载器有什么作用？
        //负责将Class文件里面的二进制数据流装载进系统，然后交给java虚拟机进行连接，初始化等操作。
        //类加载器种类:
        //启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。(java原生类库)
        //扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。(java扩展类库)
        //应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。(自己写的代码)


        //双亲委派模型
        //类加载过程中,如果类之间存在继承关系,jvm将会先加载父类,最后加载子类,因此,子类中一些静态代码块可能不会执行。
        //避免同一个类被多次加载；
        //每个加载器只能加载自己范围内的类；

        //3.类加载过程(详细) 浏览 pricture jvm
        //(1)加载(将.class文件中二进制字节流,在内存中生成一个代表这个类的java.lang.Class对象)
        //通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；
        //将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
        //在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

        //(2)验证
        //验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

        //(3)准备(只针对静态变量)
        //准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
        //这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。

        //(4)解析
        //解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
        //解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

        //(5)初始化(静态变量赋值,并且执行静态代码)
        // 静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就是<clinit>方法，即类/接口初始化方法，该方法只能在类加载的过程中由JVM调用；
        //编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量；
        //如果超类还没有被初始化，那么优先对超类初始化，但在<clinit>方法内部不会显示调用超类的<clinit>方法，由JVM负责保证一个类的<clinit>方法执行之前，它的超类<clinit>方法已经被执行。
        //JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。(所以可以利用静态内部类实现线程安全的单例模式) 如果一个类没有声明任何的类变量，也没有静态代码块，那么可以没有类<clinit>方法；(类加载只能单线程)



        //4.loadClass和forName的区别
        //Class.forName得到的class是已经初始化完成的，变量已经赋值,静态代码已经执行。(forName参数里面表示已经初始化)
        //Classloder.loadClass得到的class是还没有链接(第二步)的。
    }

    //jvm内存模型
    public void JvmJmm(){
       //资料地址 https://www.cnblogs.com/andy-zhou/p/5327288.html
        //https://www.jianshu.com/p/76959115d486
        //jmm请查看 priture 内存模型分布区域

        //1.大概了解
        //是什么
        //栈是运行时的单位，而堆是存储的单位。（栈代表了处理逻辑，而堆代表了数据）
        //栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。
        //栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的。（相应栈中只需记录堆中的一个地址即可）

        //堆中存什么？栈中存什么？
        //栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回地址等等；(相当于一个线程)
        //而堆只负责存储对象信息。（堆是所有线程共享的）
        //堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。(基本数据类型大小固定)

        //堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。而堆是为栈进行数据存储服务，说白了堆就是一块共享的内存。
        //不过，正是因为堆和栈的分离的思想，才使得Java的垃圾回收成为可能。
        //在Java中，Main函数就是栈的起始点，也是程序的起始点。

        //java对象的大小，例子：
        //Class NewObject {
        //    int count;
        //    boolean flag;
        //    Object ob;
        //}
        //其大小为：空对象大小(8byte)+int大小(4byte)+Boolean大小(1byte)+空Object引用的大小(4byte)=17byte。
        //但是因为Java在对对象内存分配时都是以8的整数倍来分，因此大于17byte的最接近8的整数倍的是24( 17 < 8*3,按8的倍数向上运算)，因此此对象的大小为24byte。


        //2.java栈(虚拟机栈)
        //栈描述的是Java方法执行的内存模型。
        //每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。
        //每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
        //注意:【栈先进后出】,就像我们调试程序,大方法包小方法，大方法最后才跳出来。

        //需要注意的是，局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，
        //这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小。(因为栈中存的是基本类型变量所以大小已经定好)

        //Java虚拟机栈可能出现两种类型的异常：（两种内存溢出异常[注意内存溢出是error级别的]）
        //线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。
        //虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。

        //3.本地栈(执行java底层native方法的栈)
        //本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，
        //而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，
        //可能就是native方法所调用的c代码。

        //4.堆
        //堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。
        //它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，
        //因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代。
        //当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存内存完成实例分配，
        //而且堆无法扩展将报OOM错误(OutOfMemoryError)

        //5.方法区(元空间)
        //方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。
        //用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。
    }

    //jvm垃圾回收
    public void JvmGC(){

    }

}
